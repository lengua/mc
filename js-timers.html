<!DOCTYPE html>
<html lang="es" xml:lang="es">
  <head>
    <meta charset="utf-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> -->
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
    <meta name="description" content="Temporizadores">
    <meta name="author" content="Santiago Chávez">
    <title>Temporizadores</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Allow web app to be run in full-screen mode. -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Temporizadores">
    <meta name="apple-mobile-web-app-title" content="Temporizadores">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <!-- Disable automatic phone number detection. -->
    <meta name="format-detection" content="telephone=no">
    <!-- FAVICON -->
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <!-- STYLES -->
    <link rel="stylesheet" type="text/css" href="w3.css">
  <style type="text/css">
    *{
      padding:0;
      margin:0;
    }
    body {
      background-color:#222;
      color: #fed;
      font-size: 24px;
    }
    .bloque {
      display: inline-block;
    }
  </style>
</head>
<body>
  CPM: <input type="number" id="defcpm" step="1"><br>
  BPC: <input type="number" id="bpc"><br>
  <button onclick="inicio();">Inicio</button><hr>
  <pre id="consola" ondblclick="dtmax=0;"></pre>
  <pre id="consola2"></pre>
  <script>
    const consola = document.getElementById('consola');
    const consola2 = document.getElementById('consola2');
    
    document.getElementById('defcpm').onchange = function() {
      defcpm = this.value;
      defbpm = defcpm*bpc;
    };
    document.getElementById('bpc').onchange = function() {
      bpc=this.value;
      defbpm = defcpm*bpc;
    };

    var getFrequency = function (nota,n,oct) {
      nota += oct*n;
      return 32.70 * Math.pow(2, (nota-1) / n);
    };
    // 'sine', // A sine wave. This is the default value.
    // 'square', // A square wave with a duty cycle of 0.5; that is, the signal is "high" for half of each period.
    // 'sawtooth', // A sawtooth wave.
    // 'triangle', // A triangle wave.
    // browsers limit the number of concurrent audio contexts, so you better re-use'em
    var a = new (window.audioContext ||window.AudioContext || window.AudioContext || window.webkitAudioContext)
    function bip(vol, freq, duration, type="triangle"){
      v=a.createOscillator()
      u=a.createGain()
      v.connect(u)
      v.frequency.value=freq
      v.type=type //"square"
      u.connect(a.destination)
      u.gain.value=vol*0.01
      v.start(a.currentTime)
      v.stop(a.currentTime+duration*0.001)
    }
  </script>
  <script>
  //
    var interval = 10; // ms
    var expected = performance.now() + interval;
    var drift_history = [];
    var drift_history_samples = 10;
    var drift_correction = 0;
    var dtmax = 0;
    var maxbpm = 0;
    var maxcpm = 0;
    var bpm = 0;
    var cpm = 0;
    var bpc = 8;// Beats por compas
    var defcpm = 30;
    var defbpm = defcpm*bpc;
    var tpb = 0; // Ticks por beat
    var errores = 0;
    var pr = 10;
    var beat = -10; // Contador de beats
    var nt = 0;     // Contador de imperceptibles a máxima
    var vol = 15; // Volumen del beep
    
    document.getElementById('bpc').value = bpc;
    document.getElementById('defcpm').value = defcpm;

    function inicio() {
      setTimeout(step, interval);
    }

    function calc_drift(arr){
      // Calculate drift correction.
      // In this example I've used a simple median.
      // You can use other methods, but it's important not to use an average. 
      // If the user switches tabs and back, an average would put far too much
      // weight on the outlier.


      var values = arr.concat(); // copy array so it isn't mutated
      
      values.sort(function(a,b){
        return a-b;
      });
      if(values.length ===0) return 0;
      var half = Math.floor(values.length / 2);
      if (values.length % 2) return values[half];
      var median = (values[half - 1] + values[half]) / 2.0;
      
      return median;
    }
    function resetear() {
      expected = performance.now();
      dt = 0.0;
      nt = 0;
      beat = -10;
      maxbpm = Math.floor(60000*pr/interval)/pr;
    }
    function step() {
      nt++;
      var dt = Math.round((performance.now() - expected)*pr)/pr; // the drift (positive for overshooting)
      if (dt > interval) {
        // something really bad happened. Maybe the browser (tab) was inactive?
        // possibly special handling to avoid futile "catch up" run
        errores++;
        // consola2.innerHTML="\nError: "+errores+"\nMaxBPM: "+maxbpm+"\ndt: "+dt+"\ninterval: "+interval;
        // consola2.innerHTML="Error: "+errores+"\ninterval: "+(Math.round(interval*pr)/pr)+"\nMaxBPM: "+(Math.round(maxbpm*pr)/pr)+"\nmax: "+(Math.round(dtmax*pr)/pr)+"\ndt: "+(Math.round(dt*pr)/pr);
        //Corrige +1
        interval+=1;
        resetear();
        // return;
      }
      // do what is to be done
           
      // don't update the history for exceptionally large values
      if (dt <= interval) {
        // sample drift amount to history after removing current correction
        // (add to remove because the correction is applied by subtraction)
          drift_history.push(dt + drift_correction);

        // predict new drift correction
        drift_correction = calc_drift(drift_history);

        // cap and refresh samples
        if (drift_history.length >= drift_history_samples) {
          drift_history.shift();
        }    
      }
      if(dt>dtmax)dtmax=dt;
      expected += interval;
      maxcpm = maxbpm/bpc;
      tpb = Math.floor(maxbpm/defbpm); //ticks por beat
      bpm = maxbpm/tpb;
      cpm = bpm/bpc;
      if(nt/tpb==Math.floor(nt/tpb)){
        beat+=1;
        if(beat>0){
          bip(vol, getFrequency(1,12,4), 100, "triangle");
        }
        consola.innerHTML="Actual: "+errores+"\nCPM: "+(Math.round(cpm*10000)/10000)+"\nBPM: "+(Math.round(bpm*1000)/1000)+"\nBeat: "+beat+"\nNT: "+nt+"\nTPB: "+(Math.round(tpb*pr)/pr)+"\ninterval: "+(Math.round(interval*pr)/pr)+"\nMaxBPM: "+(Math.round(maxbpm*pr)/pr)+"\nMaxCPM: "+(Math.round(maxcpm*pr)/pr)+"\nmax: "+(Math.round(dtmax*pr)/pr)+"\ndt: "+(Math.round(dt*pr)/pr);
      }
      // take into account drift with prediction
      setTimeout(step, Math.max(0, interval - dt - drift_correction));
    }
  //*/
  </script>
  <script>
  /*
    var interval = 20; // ms
    var dtmax = 0;
    var expected = Date.now() + interval;
    setTimeout(step, interval);
    function step() {
        var dt = Date.now() - expected; // the drift (positive for overshooting)
        if (dt > interval) {
            // something really bad happened. Maybe the browser (tab) was inactive?
            // possibly special handling to avoid futile "catch up" run
        consola.innerHTML+="dt > interval: "+dt+" > "+interval;
        return;
        }
        if(dt>dtmax)dtmax=dt;
        expected += interval;
      const mmid = Math.max(0, interval - dt);
      consola.innerHTML="max: "+dtmax+" | dt: "+dt;
        setTimeout(step, mmid); // take into account drift
    }
  //*/
  </script>
  <script>
  /*
    var interval = 20; // ms
    var dtmax = 0;
    var expected = performance.now() + interval;
    setTimeout(step, interval);
    function step() {
        var dt = performance.now() - expected; // the drift (positive for overshooting)
        if (dt > interval) {
            // something really bad happened. Maybe the browser (tab) was inactive?
            // possibly special handling to avoid futile "catch up" run
        consola.innerHTML+="dt > interval: "+dt+" > "+interval;
        return;
        }
        if(dt>dtmax)dtmax=dt;
        expected += interval;
      const mmid = Math.max(0, interval - dt);
      consola.innerHTML="max: "+dtmax+" | dt: "+dt;
        setTimeout(step, mmid); // take into account drift
    }
  //*/
  </script>
  <script>
  /*
    var interval = 20; // ms
    var expected = Date.now() + interval;
    var drift_history = [];
    var drift_history_samples = 10;
    var drift_correction = 0;
    var dtmax = 0;
    setTimeout(step, interval);

    function calc_drift(arr){
      // Calculate drift correction.
      // In this example I've used a simple median.
      // You can use other methods, but it's important not to use an average. 
      // If the user switches tabs and back, an average would put far too much
      // weight on the outlier.


      var values = arr.concat(); // copy array so it isn't mutated
      
      values.sort(function(a,b){
        return a-b;
      });
      if(values.length ===0) return 0;
      var half = Math.floor(values.length / 2);
      if (values.length % 2) return values[half];
      var median = (values[half - 1] + values[half]) / 2.0;
      
      return median;
    }

    function step() {
      var dt = Date.now() - expected; // the drift (positive for overshooting)
      if (dt > interval) {
        // something really bad happened. Maybe the browser (tab) was inactive?
        // possibly special handling to avoid futile "catch up" run
      consola.innerHTML+="\ndt > interval: "+dt+" > "+interval;
      return;
      }
      // do what is to be done
           
      // don't update the history for exceptionally large values
      if (dt <= interval) {
        // sample drift amount to history after removing current correction
        // (add to remove because the correction is applied by subtraction)
          drift_history.push(dt + drift_correction);

        // predict new drift correction
        drift_correction = calc_drift(drift_history);

        // cap and refresh samples
        if (drift_history.length >= drift_history_samples) {
          drift_history.shift();
        }    
      }
      if(dt>dtmax)dtmax=dt;
      expected += interval;
      consola.innerHTML="max: "+(Math.round(dtmax*10)/10)+" | dt: "+(Math.round(dt*10)/10);
      // take into account drift with prediction
      setTimeout(step, Math.max(0, interval - dt - drift_correction));
    }
  //*/
  </script>
  <script>
  /*

    function accuTime(interval, max, repeatArgument, callbackArgument){
      var counter = 1;

      var init = (t) => {
        let timeStart = new Date().getTime();
        setTimeout(function () {
          if (counter < max) {
            let fix = (new Date().getTime() - timeStart) - interval;
            init(t - fix);
            counter++;
          
          // event to be repeated max times
            repeatArgument(counter);
            
          } else {
          // event to be executed at animation end
            callbackArgument();
          }
        }, t);
      }
      init(interval);
    }

    var interval = 20; // ms
    var origin = new Date().getTime();
    var expected = origin-(-interval);
    var dtmax = 0;
    //example
    accuTime(interval, 1000,function(counter){
      var dt = new Date().getTime() - expected;
      if(dt>dtmax)dtmax=dt;
      consola.innerHTML="counter: "+counter+" | max: "+(Math.round(dtmax*10)/10)+" | dt: "+(Math.round(dt*10)/10);
      expected = origin - (-interval*counter);
    },function(){
      consola.innerHTML+="\nFIN";
    });

  //*/
  </script>
</body>
</html>